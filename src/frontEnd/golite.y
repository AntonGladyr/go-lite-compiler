/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>
#include <utility>
#include <string>
#include <vector>
#include "tree.h"
#include "Instruction.hpp"
#include "Statement.hpp"
#include "Declaration.hpp"
#include "ForStatement.hpp"
#include "AssignStatement.hpp"
#include "IfStatement.hpp"
#include "IfElseStatement.hpp"
#include "IncDecStatement.hpp"
#include "PrintStatement.hpp"
#include "SwitchStatement.hpp"


extern Instruction *rootIns;
// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}
%}

%code requires
{	
	#include "Instruction.hpp"
	#include "Declaration.hpp"
	#include "Statement.hpp"
	#include "Expression.hpp"
	#include "ForStatement.hpp"
	#include "AssignStatement.hpp"
	#include "IfStatement.hpp"
	#include "IfElseStatement.hpp"
	#include "IncDecStatement.hpp"
	#include "PrintStatement.hpp"
	#include "SwitchStatement.hpp"
	#include <vector>
}


/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	int intval;
	char *identifier;
    	float floatval;
    	char runeval;
    	bool boolval;
    	char *stringval;

    	Instruction *ins;
	Declaration *decl;
	Statement *stmt;
	Expression *exp;
	
	ForStatement *forStmt;
	AssignStatement *assignStmt;
	IfStatement *ifStmt;
	IfElseStatement *ifElseStmt;
	IncDecStatement *incDecStmt;
	PrintStatement *printStmt;
	SwitchStatement *switchStmt;

	std::vector<Declaration*> *var_list;
    	std::vector<Expression*> *exp_list;
    	std::vector<std::string> *id_list;
    	std::vector<std::vector<std::string>> *structdecl_list;
    	std::vector<std::pair<Expression*, Instruction*>> *case_list;
	std::vector<std::vector<std::string>> *params_list;
}

/* Token directives define the token types to be returned by the scanner (excluding character
 * tokens). Each token definition takes [optionally, a reference to the associated field in the
 * yylval union] and an identifier. Multiple tokens can eb defined per directive by using a list
 * of identifiers separated by spaces.
 */

%type <ins> program ins
%type <decl> decl varspec shortdecl
%type <stmt> stmt ifstmt loopstmt assignstmt incdecstmt printstmt returnstmt switchstmt
%type <exp> exp

%type <var_list> varspecs
%type <params_list> params_list
%type <exp_list> exp_list
%type <id_list> id_list 
%type <structdecl_list> structdecl_list
%type <case_list> case_list

%token tBREAK
%token tCASE
%token tCONST
%token tCHAN
%token tCONTINUE
%token tDEFAULT
%token tDEFER
%token tELSE
%token tFALLTHROUGH
%token tFOR
%token tFUNC
%token tGO
%token tGOTO
%token tIF
%token tIMPORT
%token tINTERFACE
%token tMAP
%token tPACKAGE
%token tRANGE
%token tRETURN
%token tSELECT
%token tSTRUCT
%token tSWITCH
%token tTYPE
%token tVAR
%token tPRINT
%token tPRINTLN
%token tAPPEND
%token tLEN
%token tCAP
%token tPLUS
%token tMINUS
%token tDIV
%token tTIMES
%token tREM
%token tBWAND
%token tBWOR
%token tBWXOR
%token tRIGHTSHIFT
%token tLEFTSHIFT
%token tBWANDNOT
%token tPLUSASSIGN
%token tMINUSASSIGN
%token tMULTASSIGN
%token tDIVASSIGN
%token tREMASSIGN
%token tBWANDASSIGN
%token tBWORASSIGN
%token tBWXORASSIGN
%token tRSHIFTASSIGN
%token tLSHIFTASSIGN
%token tBWANDNOTASSIGN
%token tAND
%token tOR
%token tARROW
%token tINC
%token tDEC
%token tEQUAL
%token tLESS
%token tGREATER
%token tASSIGN
%token tBANG
%token tNOTEQ
%token tLESSEQ
%token tGREATEREQ
%token tSHORTDECLARE
%token tELLIPSIS
%token tLBRACE
%token tLPAREN
%token tLBRACKET
%token tCOMMA
%token tPERIOD
%token tRBRACE
%token tRPAREN
%token tRBRACKET
%token tSEMICOLON
%token tCOLON
%token <identifier> tIDENTIFIER
%token <intval> tINTVAL
%token <floatval> tFLOATVAL
%token <boolval> tBOOLVAL
%token <runeval> tRUNEVAL
%token <stringval> tSTRINGVAL
%token tNEWLINE

/* Precedence directives resolve grammar ambiguities by breaking ties between shift/reduce
 * operations. Tokens are grouped into precendence levels, with lower precedence coming first
 * and then higher precedence in later directives. Tokens specified in the same directive have
 * the same precedence. Ties at the same level are broken using either %left or %right, which
 * denote left-associative and right-associative respectively.
 */

%left tPLUS tMINUS tBWOR tBWXOR
%left tTIMES tDIV tREM tBWAND tBWANDNOT tLEFTSHIFT tRIGHTSHIFT
%left tEQUAL tNOTEQ tLESS tLESSEQ tGREATER tGREATEREQ
%left tAND
%left tOR
%left pMINUS pBANG pPLUS pBWXOR

/* Start token (by default if this is missing it takes the first production */
%start program

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
 //todo: unary binary literals expressions,
%%

program : tPACKAGE tIDENTIFIER tSEMICOLON ins { /*$$ = $3; */}
    ;

ins : %empty { $$ = NULL; }
    | ins decl { /*$$ = new Instruction($1, $2);*/}
    | ins stmt { /*$$ = new Instruction($1, $2);*/ }
    | tLPAREN ins tRPAREN ins {/*$$ = new Instruction($2, $4);*/}
    ;

type : tIDENTIFIER
    | tLBRACKET tINT tRBRACKET type
    | tLPAREN type tRPAREN

decl : tVAR idlist type
    | tVAR id_list tASSIGN explist
    | tVAR id_list type tASSIGN explist

decl : tVAR varspec { /* TODO: fix //$$ = $2; */}
    | tVAR tIDENTIFIER array_indexes tIDENTIFIER tSEMICOLON { }
    | tVAR tIDENTIFIER tLBRACKET tRBRACKET tIDENTIFIER tSEMICOLON { /*literals*/ }
    | tVAR tLPAREN varspecs tRPAREN tSEMICOLON { /* TODO: fix //$$ = new Declaration(*$3); delete $3; */ } 
    | tVAR tIDENTIFIER tSTRUCT tLBRACE structdecl_list tRBRACE tSEMICOLON
    | tVAR tIDENTIFIER array_indexes tSTRUCT tLBRACE structdecl_list tRBRACE tSEMICOLON
    | tFUNC tIDENTIFIER tLPAREN params_list tRPAREN func_return_type tLBRACE ins returnstmt tRBRACE tSEMICOLON
	{ /*$$ = new FunctionDeclaration($2, *$4, $6, $8);*/ }
    | tFUNC tIDENTIFIER tLPAREN id_list tIDENTIFIER tRPAREN func_return_type tLBRACE ins returnstmt tRBRACE tSEMICOLON
    | tTYPE tIDENTIFIER identifier tSEMICOLON { /*$$ = new TypeDeclaration($2, $3);*/ }
    | tTYPE tIDENTIFIER tSTRUCT tLBRACE structdecl_list tRBRACE tSEMICOLON {/*$$ = new StructDeclaration($2, *$5);*/}
    | tTYPE tIDENTIFIER array_indexes tIDENTIFIER tSEMICOLON { /*$$ = new TypeDeclaration($2, $3);*/ }
    | tTYPE tIDENTIFIER array_indexes tSTRUCT tLBRACE structdecl_list tRBRACE tSEMICOLON {/*$$ = new StructDeclaration($2, *$5);*/} 
    | tTYPE tLPAREN typedecl_list tRPAREN tSEMICOLON { }
    | shortdecl {/*$$ = $1;*/}
    ;

array_indexes : array_index
    | array_indexes array_index { }

array_index : tLBRACKET exp tRBRACKET { }
    | tLBRACKET tRBRACKET { }

func_return_type : tIDENTIFIER
    | array_indexes tIDENTIFIER
    | %empty { /*$$ = NULL; */ }

param : id_lsit type

params_list: param
    | params_list tCOMMA param
    | %empty { $$ = NULL; } 

param: id_list tIDENTIFIER
    | id_list tLPAREN tIDENTIFIER tRPAREN
    | tIDENTIFIER array_indexes tIDENTIFIER

varspecs : %empty {/*$$ = new std::vector<Declaration*>();*/}
    | varspec {/*$$ = new std::vector<Declaration*>(); $$->push_back($1);*/}
    | varspecs varspec {/*$1->push_back($3);*/}
    ;

varspec : id_list identifier tSEMICOLON {/*$$ = new Declaration(*$1, $2);*/}
    | id_list tASSIGN exp_list tSEMICOLON {/*$$ = new Declaration(*$1, *$3);*/}
    | id_list identifier tASSIGN exp_list tSEMICOLON {/*$$ = new Declaration(*$1, *$4, $2);*/}
    ;

shortdecl : id_list tSHORTDECLARE exp_list tSEMICOLON {/*$$ = new ShortDeclaration($1, $3);*/}
    | tIDENTIFIER tSHORTDECLARE exp tSEMICOLON { }    
    | tIDENTIFIER tSHORTDECLARE array_indexes tIDENTIFIER tLBRACE exp_list tRBRACE tSEMICOLON
    ;

identifier : tIDENTIFIER
    | tLPAREN tIDENTIFIER tRPAREN
    ;

id_list : identifier {/*$$ = new std::vector<std::string>(); $$->push_back($1);*/}
    | id_list tCOMMA identifier {/*$1->push_back($3);*/}
    | %empty 
    ;

idlistne: tID
    |idlist ',' tID

idlistpe -> %empty,
    |idlistne

exp_list : 
    | exp {/*$$ = new std::vector<Expression*>(); $$->push_back($1);*/}
    | exp_list tCOMMA exp {/*$1->push_back($3);*/}
    | %empty {/*$$ = new std::vector<Expression*>();*/}
    ;

type_decl : id_list tIDENTIFIER tSEMICOLON { }
    | tIDENTIFIER tSTRUCT tLBRACE structdecl_list tRBRACE tSEMICOLON { }
    | %empty 
    ;

typedecl_list : type_decl
    | typedecl_list type_decl
    ;

structdecl : id_list tIDENTIFIER tSEMICOLON {/*$$ = new std::vector<std::vector<std::string>>(); $$->push_back(*$1);*/}
    | tIDENTIFIER tSTRUCT tLBRACE structdecl_list tRBRACE tSEMICOLON { }
    | %empty { }

structdecl_list : %empty {/*$$ = new std::vector<std::vector<std::string>>();*/}
    | structdecl {/*$$ = new std::vector<std::vector<std::string>>(); $$->push_back(*$1);*/}
    | structdecl_list structdecl {/*$1->push_back(*$3);*/}
    ;

case_list : %empty {/*$$ = new std::vector<std::pair<Expression*, Instruction*>>();*/}
    | tCASE exp tCOLON ins case_list {/*$$ = new std::vector<std::pair<Expression*, Instruction*>>(); $$->emplace_back($2, $4);*/}
    | tDEFAULT tCOLON ins case_list {/*$$->emplace_back(NULL, $4);*/}
    ;

stmt : func_call tSEMICOLON
    | loopstmt
    | assignstmt 
    | ifstmt
    | printstmt
    | returnstmt
    | switchstmt
    | op_assign_stmt
    | tBREAK tSEMICOLON {/*$$ = new BreakStatement();*/}
    | tCONTINUE tSEMICOLON {/*$$ = new ContinueStatement();*/}
    | tSEMICOLON { $$ = NULL; }
    | block_stmt { }
    ;

returnstmt : tRETURN tSEMICOLON {/*&$$ = new ReturnStatement();*/}
    | tRETURN exp tSEMICOLON {/*$$ = new ReturnStatement(exp);*/}
    | %empty { $$ = NULL; }
    ;

loopstmt : tFOR shortdecl exp tSEMICOLON assignstmt tLBRACE ins tRBRACE tSEMICOLON {/*$$ = new ForStatement($2, $4, $6, $8);*/}
    | tFOR tIDENTIFIER tASSIGN exp tSEMICOLON exp tSEMICOLON assignstmt tLBRACE ins tRBRACE tSEMICOLON {/*$$ = new ForStatement($2, $4, $6, $8);*/}
    | tFOR tSEMICOLON tSEMICOLON tLBRACE ins tRBRACE tSEMICOLON  
    | tFOR exp tLBRACE ins tRBRACE tSEMICOLON {/*$$ = new ForStatement($2, $4);*/}
    | tFOR tLBRACE ins tRBRACE tSEMICOLON {/*$$ = new ForStatement($3);*/}
    ;

assignstmt : id_list tASSIGN exp_list tSEMICOLON {/*$$ = new AssignStatement($1, $3);*/}
    | field_selectors tASSIGN exp tSEMICOLON {/*$$ = new AssignStatement($1, $3, $5);*/}
    | tIDENTIFIER array_indexes tASSIGN exp tSEMICOLON {/*$$ = new AssignStatement($1, $3, $6);*/} 
    | incdecstmt
    | incdecstmt tSEMICOLON
    | exp_list tASSIGN exp_list
    ;

ifstmt : tIF exp tLBRACE ins tRBRACE tSEMICOLON {/*$$ = new IfStatement($2, $4);*/}
    | tIF shortdecl exp tLBRACE ins tRBRACE tSEMICOLON {/*$$ = new IfStatement($3, $5, $2);*/}
    | tIF exp tLBRACE ins tRBRACE tELSE ifstmt {/*$$ = new IfElseStatement(k_stmtKindIfElse, $2, $4, $7);*/}
    | tIF shortdecl exp tLBRACE ins tRBRACE tELSE ifstmt {/*$$ = new IfElseStatement(k_stmtKindDeclIfElse, $3, $5, $8, $2);*/}
    | tIF exp tLBRACE ins tRBRACE tELSE tLBRACE ins tRBRACE tSEMICOLON{/*$$ = new IfElseStatement(k_stmtKindIfElseNested, $2, $4, $8);*/}
    | tIF shortdecl exp tLBRACE ins tRBRACE tELSE tLBRACE ins tRBRACE tSEMICOLON{/*$$ = new IfElseStatement(k_stmtKindDeclIfElseNested, $3, $5, $9, $2);*/}
    ;

incdecstmt : tIDENTIFIER tINC {/*$$ = new IncDecStatement(k_stmtKindInc, $$1);*/}
    | tINC tIDENTIFIER { }
    | tIDENTIFIER tDEC {/*$$ = new IncDecStatement(k_stmtKindDec, $$1);*/}
    | tDEC tIDENTIFIER { }
    | tIDENTIFIER tPLUSASSIGN exp {/*$$ = new IncDecStatement(k_stmtKindIncExp, $$1, $3);*/}
    | tIDENTIFIER tMINUSASSIGN exp {/*$$ = new IncDecStatement(k_stmtKindDecExp, $$1, $3);*/}
    ;

printstmt : tPRINT tLPAREN exp_list tRPAREN tSEMICOLON {/*$$ = new PrintStatement(k_stmtKindPrint, $3);*/}
    | tPRINTLN tLPAREN exp_list tRPAREN tSEMICOLON {/*$$ = new PrintStatement(k_stmtKindPrintLn, $3);*/}
    ;

switchstmt : tSWITCH tLBRACE case_list tRBRACE tSEMICOLON{/*$$ = new SwitchStatement($3);*/}
    | tSWITCH exp tLBRACE case_list tRBRACE tSEMICOLON{/*$$ = new SwitchStatement($2, $4);*/}
    | tSWITCH shortdecl tLBRACE case_list tRBRACE tSEMICOLON{/*$$ = new SwitchStatement($2, $4);*/}
    ;

op_assign_stmt : exp tPLUSASSIGN exp{ }
    | exp tMINUSASSIGN exp { }
    | exp tMULTASSIGN exp { }
    | exp tDIVASSIGN exp { }
    | exp tREMASSIGN exp { }
    | exp tBWANDASSIGN exp { }
    | exp tBWORASSIGN exp { }
    | exp tBWXORASSIGN exp { }
    | exp tLSHIFTASSIGN exp { }
    | exp tRSHIFTASSIGN exp { }
    | exp tBWANDNOTASSIGN exp { }


block_stmt: tLBRACE ins tRBRACE tSEMICOLON
    ;

func_call : tIDENTIFIER tLPAREN id_list tRPAREN {/*$$ = new Binary(k_exprKindFunctionCall, $1, $3);*/}
    | tIDENTIFIER tLPAREN exp_list tRPAREN { } 
    | tLPAREN tIDENTIFIER tRPAREN tLPAREN exp_list tRPAREN
    ; 

selector : tIDENTIFIER
    | tIDENTIFIER array_indexes

field_selectors : selector tPERIOD selector { }
    | field_selectors tPERIOD selector { }

exp : tIDENTIFIER { }
    | field_selectors {/*$$ = new Binary(k_exprKindFieldSelector, $1, $3);*/}
    | field_selectors array_indexes
    | tIDENTIFIER array_indexes {/*$$ = new Binary(k_exprKindIndexer, $1, $3);*/}
    | func_call
    | func_call array_indexes
    | tAPPEND tLPAREN exp tCOMMA exp tRPAREN {/*$$ = new Binary(k_exprKindAppend, $3, $5);*/}
    | tLEN tLPAREN exp tRPAREN {/*$$ = new Binary(k_exprKindLen, $3);*/}
    | tCAP tLPAREN exp tRPAREN {/*$$ = new Binary(k_exprKindCap, $3);*/}
    | tLPAREN exp tRPAREN { } 
    | exp tPLUS exp {/*$$ = new Unary(k_exprKindPlus, $2);*/}
    | exp tMINUS exp {/*$$ = new Unary(k_exprKindMinus, $2);*/}
    | exp tTIMES exp { } 
    | exp tDIV exp { }
    | exp tREM exp { }
    | exp tBWAND exp { }
    | exp tBWOR exp { } 
    | exp tBWXOR exp {/*$$ = new Unary(k_exprKindBwxor, $2);*/}
    | exp tLEFTSHIFT exp { }
    | exp tRIGHTSHIFT exp { }
    | exp tBWANDNOT exp { }
    | exp tAND exp { } 
    | exp tOR exp { } 
    | exp tEQUAL exp { } 
    | exp tNOTEQ exp { } 
    | exp tGREATER exp { }
    | exp tLESS exp { } 
    | exp tGREATEREQ exp { } 
    | exp tLESSEQ exp { }
    | tINTVAL {/*$$ = new Literal(k_exprKindInt, $1);*/}
    | tFLOATVAL {/*$$ = new Literal(k_exprKindFloat, $1);*/}
    | tRUNEVAL {/*$$ = new Literal(k_exprKindChar, $1);*/}
    | tSTRINGVAL {/*$$ = new Literal(k_exprKindChar, $1);*/}
    | tBOOLVAL {/*$$ = new Literal(k_exprKindBool, $1);*/}
    | tIDENTIFIER {/*$$ = new Literal(k_exprKindIdentifier, $1);*/}
    | tBANG exp %prec pBANG {/*$$ = new Unary(k_exprKindBang, $2);*/}
    | tMINUS exp %prec pMINUS { }
    | tPLUS exp %prec pPLUS { }
    | tBWXOR exp %prec pBWXOR
    ; 

%%
